
Every single function call has an associated value to it. When you call a function, you have to pay a value to it be write in the blocks. 

To understand this better, look up to eth-converter.com

    1 Wei    => 0.000000001 Gwei => 0.000000000000000001 Ether

    1 Ether  => 1000000000 Gwei  => 1000000000000000000  Wei

    In other words: 1 ether = 1 * 10^8  Gwei;
                    1 ether = 1 * 10^18  Wei;
 
 
PAYABLE FUCTIONS  
    
    When we define a function as payable, we tell to Solidity that funcition shall receive money transfers in it's transactions. With that in mind, that function starts to have access to two types of messages: 

        msg.sender -> the address of the person who sent the transaction, the sender that calls that function in that moment in time;
    
        msg.value  -> the value that was sent in the transaction;
        
        
    When I call that function, I have to pass the value I want it to process
    
    
ORACLES

    There are some limitations in the use of blockchains. Since every transaction in one block inside a node must be reproduce in every other node, the transactions must be deterministic in it entirety. What does that mean? Well, mathematical operations are deterministic; 1 + 1 will always be 2, doens't matter WHEN we try to perform it.
    
    But there are some operations that are non-deterministic. Imagine the following:
    
        uint256 test = random();
    
    The variable receives a random value, cool. But, how another node is going to run THE SAME TRANSACTION and get the EXACT SAME random value if, by definition, each time I call the random() function it returns a different result?
    
    Got the problem? And it extends even further: imagine that I call an API. If I call the API NOW, the result might be one thing. If I call it later, it might be 
    another (imagine I'm calling a database that gets more data in the time between two nodes are updated). In this type of situations, the consensus might not be reach between multiple nodes.
    
    That's where oracles go in. But we have another problem: oracles might send data to our blockchain code, but they can't become a single point of failure in the process. CHAINLINK might help us in this process.
    
    PROBLEM: there are no nodes running chainlink in the Javascript VM (the local network), so to test chainlink we have to go on and use the testing network with
             our metamask.
             
             
             
TUPLES

    List of data of potentially different types. Example:
    
        (uint80 test1, int256 answer, uint256 startedAt)
        
    If a function returns a tuple, we can instantiate variables for each of the results. For example, imagine I have a function *makeItHappen* that returns the tuple above.
    
        (uint80 variable1, int256 variable2, uint25 beginDate) = makeItHappen();
    
    Now imagine that you don't need all the values, just the beginDate. You could do:
    
        (,, uint25 beginDate) = makeItHappen();

    And that's it, brother <3
    
    
LIBRARY
    
    Are similar to contracts, but their purpose is that they are deployed only once at a specific address and their code is reused.
    
USING

    Can be used to attach library functions (from the library A) to any type (B) in the context of a contract.

    
OVERFLOW ERROR

    For Solidity under version 0.8.0, there's a problem with mathematical operations. If we use a variable uint8 with the number 255 and sum it with another uint8 with 1, we shall see the result as 0. If we sum with 100, we shall see a result 99. That happens because the number resets when an overflow occurs, and the result shall be a restart count from 0.
    
    To avoid that using Solidity < 0.8.0, we could use the SafeMathChainlink.sol from the chainlink npm library as follows.
    
    pragma solidity 0.6.0
    
    import "@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol";
    
    contratcs TestContract
    {
        using SafeMathChainlink for uint8;
        
                    ...
    }
    
REQUIRE STATEMENT

    When a function call reaches the require() statement, it checks for a validation. If it returns true, the function keeps it execution. If it's not, then we stop the function execution (it's going to revert the transaction -> the user gets his money back and no one, no one has to cry his eyes out).

MODiFIER

    Is used to change the behaviour of a function in a declarative way. Example:

        address owner;

                                ...

        modifier onlyOwner{
            require(msg.sender == owner);   //Line that owr modifier must execute
            _;                              //Line that says: execute all the code as normally from here on;
        }

        //adding our modifier call to the function. So, the modifier shall be called and THEN the function will be executed
        function withdraw() payable onlyOwner public { 
                            ...
        }

